# leetcode .31 下一个排列
## 题目描述
> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

>必须原地修改，只允许使用额外常数空间。

>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```


## 思路
* 要找到比当前数字大的数字
* 限制因素是所有比当前数字大的最小数字  

最开始的朴素思路是找到一个比数组末尾数字小的数字，二者交换  
但很快就发现了问题  
如```1,3,2```根据这个思路会变成2，3，1，这个数字明显比2，1，3大  
这样依靠直觉思考下去显然是没有效果的  
鉴于我就是个辣鸡，接下来我就直接参考题解了   
利用图形化思想，引用leetcode大佬Imageslr的思路  
把数组组成的字符串想象成一段折线，如果要找到比当前数字大的数字，应该在这个折线段的低点找到一个值与他互换，那这个值是在哪里呢?  
显然不可能在这个低点前面，故直接从后面往前遍历找到比这个低点大的数字，为什么是从后往前遍历呢？为什么不干脆从低点往后遍历？  
因为我们在构造这个数字时要时刻牢记一个点，构造的数字是比当前数字大的数字中的最小数字，并且这个算法是一环扣一环的，我们之前找低点时就反映了这样一个趋势，就是自点j后数字均比j小，j之前数字i也比i小，所以为了满足找以上找数字原则也就自然而然的从后往前找数了  
找到该数后将其与低点交换，但这样还没有完全成功，因为这样的数字仍然不是最小数字，为了满足此条件将i后数字均qsort一下就ok了  



## 代码
```C
void nextPermutation(int* nums, int numsSize){
    int cmpfunc (const void * a, const void * b)
    {
            return ( *(int*)a - *(int*)b );
    }
    int i=numsSize-2,j=numsSize-1;
    while(i!=-1&&j!=-1)
    {
        if(nums[i]<nums[j])
        break;
        i--;
        j--;
    }
    if(i!=-1){
    for (int k=numsSize-1;k>j-1;k--){
        if(nums[k]>nums[i])
        {
            int x=nums[i];
        nums[i]=nums[k];
        nums[k]=x;
        qsort(nums+i+1, numsSize-i-1, sizeof(int), cmpfunc);
        break;
        }
    }
    }
    if(i==-1)
    {
        qsort(nums, numsSize, sizeof(int), cmpfunc);    
    }
}
```
